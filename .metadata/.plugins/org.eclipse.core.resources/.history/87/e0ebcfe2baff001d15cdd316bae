package com.almarsoft.GroundhogReader.lib;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.net.SocketException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.commons.net.io.DotTerminatedMessageReader;
import org.apache.commons.net.nntp.Article;
import org.apache.commons.net.nntp.NNTPConnectionClosedException;
import org.apache.commons.net.nntp.NewsgroupInfo;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;
import android.util.Log;

/**
 * Single class, used to maintain a connection to the server. If the connection is broken, it will 
 * try to reconnect. 
 * 
 * IMPORTANT: in order to keep the connection transparently, all the methods of this class that use mClient must follow
 * this pattern:
 
 
public int myMethod(int param1) throws IOException {

		try {
		
			// Your code goes here
			mClient.something();
			int retvalue = someotherthing();
			
			// End of the method code, start of the boilerplate code 
 
		} catch (IOException e) {
			if (mRetrying) throw(e);
			else mRetrying = true;
        }
        	
		if (mRetrying) {
			connect(true);
			return myMethod(param1);
		}

		mRetrying = false;
		return msgNumbers;
} 
 
This is ugly: YES. But the problem is that mClient.isConnected() is not very reliably; it always says the true when mClient.isConnected() 
== false but when it returns true sometimes the internal socket is NOT really connected and a SocketException or NNTPException (both sons
of IOException) is launched. So what I'm doing here  is a retry that forces the reconneciton and calls the same method again, but only once (that's
the reason to have a field mRetrying.)

 */

final public class ServerManager {

	private String mGroup;
	private int mGroupID;

	private NNTPExtended mClient = null;
	private NewsgroupInfo mGroupInfo;
	private MiniMime minime;
	private Context mContext;
	private HashSet<String> mBannedThreadsSet;
	private HashSet<String> mBannedTrollsSet;
	
	
	public ServerManager(Context callerContext) {

		mContext = callerContext;
		minime = new MiniMime();

		mBannedTrollsSet  = DBUtils.getBannedTrolls(mContext);
	}
	
	
	protected void finalize() throws Throwable
	{
		if (mClient != null && mClient.isConnected()) {
			try {
				mClient.disconnect();
			} catch (IOException e) {
				Log.d("XXX", "ServerManager, exception launched on finalize()");
				e.printStackTrace();
			}
		}
	}

	// Connect to the server configured in the settings. Please note that mClient.isConnected
	// works when it says that you are not connected but NOT when is returns "you're connected", for
	// example after a phone sleep it will usually say true while in fact the socket died. That's the 
	// reason of the ugly try { } catch() { reconnect_and_try_again }
	public void clientConnectIfNot() throws IOException, ServerAuthException {
		
		Log.d("XXX", "en ClientConnectIfNot");
		if (mClient == null || !mClient.isConnected()) {
			Log.d("XXX", "clientConnectIfNot: estaba desconectado, reconectando");
			connect();
		} else
			Log.d("XXX", "clientConnectIfNot: segun esto estaba conectado...");
	}

	
	private void connect() throws SocketException, IOException, ServerAuthException {
		
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(mContext);
		
		int port          = new Integer(prefs.getString("port", "119").trim());
		boolean needsAuth = prefs.getBoolean("needsAuth", false);
		
		String host = prefs.getString("host", null);
		if (host != null) host = host.trim();
		
		String clogin = prefs.getString("login", null);
		if (clogin != null) clogin = clogin.trim();
		
		String cpass = prefs.getString("pass", null);
		if (cpass != null) cpass = cpass.trim();

			mClient = new NNTPExtended();
			mClient.set
			
		// Get the configuration host, port, username and pass
		mClient.connect(host, port);
		if (needsAuth) {
			if (!mClient.authenticate(clogin, cpass)) {
				throw new ServerAuthException();
			}
		}
	}

	
	public boolean selectNewsGroup(String group) throws ServerAuthException, IOException {
		
		// Don't select anything if we're already selected on this group
		if (mGroup != null && group == mGroup) return true;
		
		mGroup = group;
		mGroupID = DBUtils.getGroupIdFromName(group, mContext);
		mBannedThreadsSet = DBUtils.getBannedThreads(group, mContext);
		
		clientConnectIfNot();

		try {
			mGroupInfo = new NewsgroupInfo();
			mClient.selectNewsgroup(mGroup, mGroupInfo);
			return true;

		} catch (IOException e) {
			Log.d("ArticleGetter", e.toString());
		}
		
		return false;
	}

	
	// =====================================================================================
	// Retrieve the list of article numbers from the server and return a vector
	// of articles
	// considering the user limit
	// =====================================================================================

	public Vector<Integer> getArticleNumbers(int firstMsg, int limit) throws IOException, ServerAuthException {
		clientConnectIfNot();
		
		Vector<Integer> msgNumbers = new Vector<Integer>(limit);
	
		int[] allNumbers = mClient.listGroup(mGroup);

		int countSaved = 0;
		int init;
		
		if (firstMsg == -1 && allNumbers.length > limit) {
			// Special case for first time entering a group; instead of getting the 100 (or limit) 
			// older we get the 100 newer
			init = allNumbers.length - limit;
			
		} else {
			init = 0;
		}

		for (; init < allNumbers.length; init++) {
			if (allNumbers[init] < firstMsg)
				continue;
			if (countSaved > limit)
				break;
			msgNumbers.add(new Integer(allNumbers[init]));
			countSaved++;
		}
			
		return msgNumbers;

	}

	// ===============================================================================
	// Retrieve and article by number from the server and store it into the
	// database
	// ===============================================================================

	public boolean getAndInsertArticle(int articleNumber) throws IOException, UsenetReaderException, ServerAuthException {
		clientConnectIfNot();
		
		String decodedfrom;

		
		// Get the article information (shorter than the header; we'll fetch the
		// header and the
		// body when the user clicks on an article.)
		Article articleInfo = getArticleInfo(articleNumber);

		if (articleInfo != null) {
			
			decodedfrom = minime.decodemime(articleInfo.getFrom(), true);
			
			if (  (!mBannedThreadsSet.contains(articleInfo.simplifiedSubject())) 
			    &&(!mBannedTrollsSet.contains(decodedfrom))) {
				
				insertArticleInDB(articleInfo, articleNumber, decodedfrom);
			} 
			
			return true;
		}
		return false;
	}

	
	private Article getArticleInfo(int articleNumber) throws IOException, ServerAuthException {
		clientConnectIfNot();
		
		Article article = null;
		
		Reader reader = (DotTerminatedMessageReader) mClient.retrieveArticleInfo(articleNumber);

		if (reader != null) {
			String theInfo = readerToString(reader);

			if (theInfo.trim().length() == 0) {
				return null;
			}
			StringTokenizer st = new StringTokenizer(theInfo, "\n");

			// Extract the article information
			// Mandatory format (from NNTP RFC 2980) is :
			// Subject\tAuthor\tDate\tID\tReference(s)\tByte Count\tLine Count

			StringTokenizer stt = new StringTokenizer(st.nextToken(), "\t");
			article = new Article();
			article.setArticleNumber(Integer.parseInt(stt.nextToken()));
			article.setSubject(stt.nextToken());
			article.setFrom(stt.nextToken());
			article.setDate(stt.nextToken());
			article.setArticleId(stt.nextToken());
			//article.addHeaderField("References", stt.nextToken());
			String[] refs = stt.nextToken().split(" ");

			for (int i = 0; i < refs.length; i++) 
				article.addReference(refs[i]);
		}
			
		return article;
	}
	
	
	public String getBody(int msgnum) throws IOException, ServerAuthException {		
		clientConnectIfNot();
		String body = null;
		
		Reader reader = (DotTerminatedMessageReader) mClient.retrieveArticleBody(msgnum);
		body = readerToString(reader);
			
		return body;
	}

	
	private String readerToString(Reader reader) throws IOException {
		String temp = null;
		StringBuffer sb = null;
		BufferedReader bufReader = new BufferedReader(reader);

		sb = new StringBuffer();

		temp = bufReader.readLine();
		while (temp != null) {
			sb.append(temp);
			sb.append("\n");
			temp = bufReader.readLine();
		}

		return sb.toString();
	}

	
	private void insertArticleInDB(Article articleInfo, int articleNumber, String decodedfrom) throws UsenetReaderException {

		// Get the reference list as a string instead of as an array of strings
		// for insertion into the DB
		String[] references = articleInfo.getReferences();
		StringBuffer references_buff = new StringBuffer();
		references_buff.append("");

		for (int i = 0; i < references.length; i++) {
			if (i == (references.length - 1)) {
				references_buff.append(references[i]);
			} else {
				references_buff.append(references[i] + " ");
			}
		}
		
		String finalRefs = references_buff.toString();
		String finalSubject = minime.decodemime(articleInfo.getSubject(), false);

		// Now insert the Article into the DB
		DBUtils.insertArticleToGroupID(mGroupID, articleInfo, finalRefs, decodedfrom, finalSubject, mContext);
	}

	
	// ================================================================
	// Get a message header and return a Hashtable with the field names
	// as keys and the mime-decoded values as values
	// ================================================================
	
	public HashMap<String, String> getHeader(int msgnum) throws IOException, ServerAuthException {
		clientConnectIfNot();
		
		Log.d("XXX", "XXXXXXXXXXXXXXXXXX EN GETHEADER");
		
		HashMap<String, String> headerTable = null;
		Reader reader = (DotTerminatedMessageReader) mClient.retrieveArticleHeader(msgnum);
		
		if (reader != null) {
			String theHeader = readerToString(reader);

			if (theHeader.trim().length() == 0) 
				return null;
			
			String[] headerFields = theHeader.split("\n");
			String[] fieldValue = null;
			headerTable = new HashMap<String, String>(headerFields.length);
			String lastField = "";
			
			for (int i = 0; i < headerFields.length; i++) {
				
				fieldValue = headerFields[i].split(":", 2);
				
				if (fieldValue.length < 2) {
					
					// Multiline header, add to the previous field
					if (lastField.compareTo("From") != -1 || lastField.compareTo("Subject") != -1)
						headerTable.put(lastField, headerTable.get(lastField) + minime.decodemime(fieldValue[0], false));
					else
						headerTable.put(lastField, headerTable.get(lastField) + fieldValue[0]);
					
				} else {
					// Normal one line field or first line of a multiline field
					
					if (fieldValue[0].compareTo("From") == 0 || fieldValue[0].compareTo("Subject") == 0) {
						headerTable.put(fieldValue[0], minime.decodemime(fieldValue[1].trim(), false));
					}
					else
						headerTable.put(fieldValue[0], fieldValue[1].trim());
					lastField = fieldValue[0];
				}
			}
		}	
			
		return headerTable;
	}


	public NewsgroupInfo[] listNewsgroups(String wildmat) throws IOException, ServerAuthException {
		clientConnectIfNot();

		NewsgroupInfo[] retVal = null;
			
		retVal = mClient.listNewsgroups(wildmat);
		
		return retVal;
	}
	
	
	public String postArticle(String header, String body, String signature) throws IOException, ServerAuthException {
		clientConnectIfNot();
		
		String error = null;
			
		Writer writer = mClient.postArticle();
		
		if (writer != null) {
			writer.write(header + "\n\n");
			writer.write(body);
			writer.write(signature);
			writer.close();
			if (!mClient.completePendingCommand())
				error = mClient.getReplyString();
			
		}
			
		return error;
	}
}
