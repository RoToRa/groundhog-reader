package com.almarsoft.GroundhogReader.lib;

/*
 * @(#)UUDecoder.java	1.13 00/02/02
 *
 * Copyright 1995-2000 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * This software is the proprietary information of Sun Microsystems,
 * Inc. Use is subject to license terms.
 * 
 */

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import sun.misc.CEFormatException;
import sun.misc.CEStreamExhausted;
import sun.misc.CharacterDecoder;
import sun.misc.UUEncoder;

      /*
       * Copyright 1995-2004 Sun Microsystems, Inc.  All Rights Reserved.
       * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
       *
       * This code is free software; you can redistribute it and/or modify it
       * under the terms of the GNU General Public License version 2 only, as
       * published by the Free Software Foundation.  Sun designates this
       * particular file as subject to the "Classpath" exception as provided
       * by Sun in the LICENSE file that accompanied this code.
      *
      * This code is distributed in the hope that it will be useful, but WITHOUT
      * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
      * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
      * version 2 for more details (a copy is included in the LICENSE file that
      * accompanied this code).
      *
      * You should have received a copy of the GNU General Public License version
      * 2 along with this work; if not, write to the Free Software Foundation,
      * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
      *
      * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
      * CA 95054 USA or visit www.sun.com if you need additional information or
      * have any questions.
      */
     
     package sun.misc;
     
     import java.io.OutputStream;
     import java.io.ByteArrayOutputStream;
     import java.io.InputStream;
     import java.io.PushbackInputStream;
     import java.io.ByteArrayInputStream;
     import java.io.IOException;
     import java.nio.ByteBuffer;
     
     /**
37      * This class defines the decoding half of character encoders.
38      * A character decoder is an algorithim for transforming 8 bit
39      * binary data that has been encoded into text by a character
40      * encoder, back into original binary form.
41      *
42      * The character encoders, in general, have been structured
43      * around a central theme that binary data can be encoded into
44      * text that has the form:
45      *
46      * <pre>
47      *        [Buffer Prefix]
48      *        [Line Prefix][encoded data atoms][Line Suffix]
49      *        [Buffer Suffix]
50      * </pre>
51      *
52      * Of course in the simplest encoding schemes, the buffer has no
53      * distinct prefix of suffix, however all have some fixed relationship
54      * between the text in an 'atom' and the binary data itself.
55      *
56      * In the CharacterEncoder and CharacterDecoder classes, one complete
57      * chunk of data is referred to as a <i>buffer</i>. Encoded buffers
58      * are all text, and decoded buffers (sometimes just referred to as
59      * buffers) are binary octets.
60      *
61      * To create a custom decoder, you must, at a minimum,  overide three
62      * abstract methods in this class.
63      * <DL>
64      * <DD>bytesPerAtom which tells the decoder how many bytes to
65      * expect from decodeAtom
66      * <DD>decodeAtom which decodes the bytes sent to it as text.
67      * <DD>bytesPerLine which tells the encoder the maximum number of
68      * bytes per line.
69      * </DL>
70      *
71      * In general, the character decoders return error in the form of a
72      * CEFormatException. The syntax of the detail string is
73      * <pre>
74      *        DecoderClassName: Error message.
75      * </pre>
76      *
77      * Several useful decoders have already been written and are
78      * referenced in the See Also list below.
79      *
80      * @version        05/05/07, 1.29
81      * @author        Chuck McManis
82      * @see                CEFormatException
83      * @see                CharacterEncoder
84      * @see                UCDecoder
85      * @see                UUDecoder
86      * @see                BASE64Decoder
87      */
     
     public abstract class CharacterDecoder {
     
         /** Return the number of bytes per atom of decoding */
         abstract protected int bytesPerAtom();
     
         /** Return the maximum number of bytes that can be encoded per line */
         abstract protected int bytesPerLine();
     
         /** decode the beginning of the buffer, by default this is a NOP. */
         protected void decodeBufferPrefix(PushbackInputStream aStream, OutputStream bStream) throws IOException { }
     
        /** decode the buffer suffix, again by default it is a NOP. */
        protected void decodeBufferSuffix(PushbackInputStream aStream, OutputStream bStream) throws IOException { }
    
        /**
         * This method should return, if it knows, the number of bytes
105         * that will be decoded. Many formats such as uuencoding provide
106         * this information. By default we return the maximum bytes that
107         * could have been encoded on the line.
108         */
        protected int decodeLinePrefix(PushbackInputStream aStream, OutputStream bStream) throws IOException {
            return (bytesPerLine());
        }
    
        /**
114         * This method post processes the line, if there are error detection
115         * or correction codes in a line, they are generally processed by
116         * this method. The simplest version of this method looks for the
117         * (newline) character.
118         */
        protected void decodeLineSuffix(PushbackInputStream aStream, OutputStream bStream) throws IOException { }
    
        /**
122         * This method does an actual decode. It takes the decoded bytes and
123         * writes them to the OutputStream. The integer <i>l</i> tells the
124         * method how many bytes are required. This is always <= bytesPerAtom().
125         */
        protected void decodeAtom(PushbackInputStream aStream, OutputStream bStream, int l) throws IOException {
            throw new CEStreamExhausted();
        }
    
        /**
131         * This method works around the bizarre semantics of BufferedInputStream's
132         * read method.
133         */
        protected int readFully(InputStream in, byte buffer[], int offset, int len)
            throws java.io.IOException {
            for (int i = 0; i < len; i++) {
                int q = in.read();
                if (q == -1)
                    return ((i == 0) ? -1 : i);
                buffer[i+offset] = (byte)q;
            }
            return len;
        }
    
        /**
146         * Decode the text from the InputStream and write the decoded
147         * octets to the OutputStream. This method runs until the stream
148         * is exhausted.
149         * @exception CEFormatException An error has occured while decoding
150         * @exception CEStreamExhausted The input stream is unexpectedly out of data
151         */
        public void decodeBuffer(InputStream aStream, OutputStream bStream) throws IOException {
            int        i;
            int        totalBytes = 0;
    
            PushbackInputStream ps = new PushbackInputStream (aStream);
            decodeBufferPrefix(ps, bStream);
            while (true) {
                int length;
    
                try {
                    length = decodeLinePrefix(ps, bStream);
                    for (i = 0; (i+bytesPerAtom()) < length; i += bytesPerAtom()) {
                        decodeAtom(ps, bStream, bytesPerAtom());
                        totalBytes += bytesPerAtom();
                    }
                    if ((i + bytesPerAtom()) == length) {
                        decodeAtom(ps, bStream, bytesPerAtom());
                        totalBytes += bytesPerAtom();
                    } else {
                        decodeAtom(ps, bStream, length - i);
                        totalBytes += (length - i);
                    }
                    decodeLineSuffix(ps, bStream);
                } catch (CEStreamExhausted e) {
                    break;
                }
            }
            decodeBufferSuffix(ps, bStream);
        }
    
        /**
183         * Alternate decode interface that takes a String containing the encoded
184         * buffer and returns a byte array containing the data.
185         * @exception CEFormatException An error has occured while decoding
186         */
        public byte decodeBuffer(String inputString)[] throws IOException {
            byte        inputBuffer[] = new byte[inputString.length()];
            ByteArrayInputStream inStream;
            ByteArrayOutputStream outStream;
    
            inputString.getBytes(0, inputString.length(), inputBuffer, 0);
            inStream = new ByteArrayInputStream(inputBuffer);
            outStream = new ByteArrayOutputStream();
            decodeBuffer(inStream, outStream);
            return (outStream.toByteArray());
        }
    
        /**
200         * Decode the contents of the inputstream into a buffer.
201         */
        public byte decodeBuffer(InputStream in)[] throws IOException {
            ByteArrayOutputStream outStream = new ByteArrayOutputStream();
            decodeBuffer(in, outStream);
            return (outStream.toByteArray());
        }
    
        /**
209         * Decode the contents of the String into a ByteBuffer.
210         */
        public ByteBuffer decodeBufferToByteBuffer(String inputString)
            throws IOException {
            return ByteBuffer.wrap(decodeBuffer(inputString));
        }
    
        /**
217         * Decode the contents of the inputStream into a ByteBuffer.
218         */
        public ByteBuffer decodeBufferToByteBuffer(InputStream in)
            throws IOException {
            return ByteBuffer.wrap(decodeBuffer(in));
        }
    }
